%header {:
 // this code is inlined before the generated parser
package minijava;
:};

%terminals kw_class,  kw_public, kw_static, kw_void, kw_while, kw_if, kw_else, kw_extends, kw_return, kw_System_out_println, kw_this, kw_new, kw_main,
                t_String, t_int, t_boolean,
                sym_open, sym_open_square, sym_open_curly, sym_close, sym_close_square, sym_close_curly, sym_semicolon, sym_comma, sym_equals, sym_dot_len, sym_dot, 
                sym_exclam, sym_logic_and, sym_plus, sym_minus, sym_mult, sym_less,
                c_true, c_false,
                integer_lit,
                ident;

%typeof Goal = "Program";
%typeof Program = "Program";
%typeof op = "Op";
%typeof id = "Id";
%typeof ExpRest = "ExpRest";
%typeof ExpList = "ExpList";
%typeof Exp = "Exp";
%typeof Statement = "Statement";
%typeof Type = "Type";
%typeof ParamRest = "ParamList";
%typeof MethodDecl = "MethodDecl";
%typeof VarDecl = "VarDecl";
%typeof ClassDecl = "ClassDecl";
%typeof MainClass = "MainClass";


%goal Goal;

// Productions with semantic actions building the JastAdd AST

Goal = Program;

Program = MainClass ClassDecl*;

MainClass = kw_class id sym_open_curly kw_public kw_static kw_void kw_main sym_open t_String sym_open_square sym_close_square id sym_close sym_open_curly VarDecl* Statement* sym_close_curly sym_close_curly;

ClassDecl = kw_class id sym_open_curly VarDecl* MethodDecl* sym_close_curly 
		| kw_class id kw_extends id sym_open_curly VarDecl* MethodDecl* sym_close_curly;

VarDecl = Type id sym_semicolon;

MethodDecl = kw_public Type id sym_open ?ParamList sym_close sym_open_curly VarDecl* Statement* kw_return Exp sym_semicolon sym_close_curly;

ParamList = Type id ParamRest*;

ParamRest = sym_comma Type id;

Type = t_int sym_open_square sym_close_square 											{: return new IntArrType(); :}
		| t_boolean																		{: return new BooleanType(); :} 
		| t_int 																		{: return new IntType(); :}
		| id.i																			{: return new IdType(i); :};

Statement = sym_open_curly Statement* sym_close_curly 
        | kw_if sym_open Exp sym_close Statement kw_else Statement
        | kw_while sym_open Exp sym_close Statement
        | kw_System_out_println sym_open Exp sym_close sym_semicolon
        | id sym_equals Exp sym_semicolon
        | id sym_open_square Exp sym_close_square sym_equals Exp sym_semicolon;

Exp = Exp.l op.o Exp.r																	{: return new BinOpExp(l,o,r); :}
        | Exp.f sym_open_square Exp.p sym_close_square									{: return new ArrayExp(f,p); :}
        | Exp.f sym_dot_len																{: return new LengthExp(f); :}
        | Exp.f sym_dot id.m sym_open ?ExpList.p sym_close								{: return new MethodExp(f,m,p); :}
        | c_true																		{: return new TrueExp(); :}
        | c_false																		{: return new FalseExp(); :}
        | id.i																			{: return new IdExp(i); :}
        | integer_lit.i																	{: return new IntLit(i.value.toString()); :}
        | kw_this																		{: return new ThisExp(); :}
        | kw_new t_int sym_open_square Exp.g sym_close_square							{: return new IntArrExp(g); :}
        | kw_new id.k sym_open sym_close												{: return new NewExp(k); :}
        | sym_exclam Exp.e																{: return new NotExp(e); :}
        | sym_open Exp.e sym_close														{: return new Geklammert(e); :};
        
ExpList = Exp ExpRest*;

ExpRest = sym_comma Exp;

id = ident.i																			{: return new Id(i.value.toString()); :};

op = sym_logic_and																		{: return new And(); :}
        | sym_plus																		{: return new Plus(); :}
        | sym_minus																		{: return new Minus(); :}
        | sym_mult																		{: return new Mul(); :}
        | sym_less																		{: return new Less(); :};